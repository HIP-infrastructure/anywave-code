// AnyWave
// Copyright (C) 2013-2021  INS UMR 1106
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
#pragma once

//#include "CTFStdTypes.h"
#include "MEGTypes.h"
#include "vector_math.h"
#ifdef OS_LINUX_2_2
#define __PACKED__ __attribute__ ((aligned( 2 )))
#else
#define __PACKED__
#endif 

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
#define MAX_COILS 8
#define SENSOR_LABEL 31
#define MAX_NUM_COEFS 50
#define MAX_AVERAGE_BINS 8
#define MAX_BALANCING MAX_NUM_COEFS
#define GENERALRESID 30000
#define G1BRINDEX 1 /* Define index for the coefficients. */
#define G2BRINDEX 2
#define G3BRINDEX 3
#define G2OIINDEX 4
#define G3OIINDEX 5
#define EDDYINDEX 6
#define G1OIINDEX 7 

	/**
	Constant for designating the bad segments file.
	The file extension must match the constant SEGMENTS_FILE_EXT
	defined in CTFSegment.cc.
	*/
	const string BAD_SEGMENTS_FILENAME = "bad.segments";
	//## WARNING This list is order sensitive
	//## It must match the order of the stypes array
	//## in Channel.cc
	//## DO NOT CHANGE ANY EXISTING VALUES
	//## Otherwise existing data set can not be accessed properly
	//
	typedef enum {
		eMEGReference, //!< MEG sensors located above the helmet, measures background noise
		eMEGReference1,
		eMEGReference2,
		eMEGReference3,
		eMEGSensor, //!< MEG sensors located in the helmet, measures head and background noise
		eMEGSensor1,
		eMEGSensor2,
		eMEGSensor3,
		eEEGRef, //!< EEG unipolar sensors that are not on the scalp
		eEEGSensor, //!< EEG unipolar sensors that are on the scalp
		eADCRef,
		eADCAmpRef = eADCRef, //!< ADC amp channels from UPI/PIU
		eStimRef, //!< Stimulus channel for MEG41
		eTimeRef, //!< Time ref coming from video channel
		ePositionRef, //!< Unused now, could measure position and orientation of dipole
		eDACRef, //!< DAC channel from UPI or HLU
		eSAMSensor, //!< SAM channel derived through data analysis
		eVirtualSensor, //!< Virtual channel derived by combining 2 or more physical channels
		eSystemTimeRef, //!< System time showing elapsed time since trial started
		eADCVoltRef, //!< ADC volt channels from UPI
		eStimAnalog, //!< Analog trigger channels
		eStimDigital, //!< Digital trigger channels
		eEEGBipolar, //!< EEG bipolar sensor, that will not be on the scalp
		eEEGAflg, //!< EEG ADC Over range flags
		eMEGReset, //!< MEG resets - counts sensor jumps/resets for cross talk purposes
		eDipSrc, //!< Dipole source
		eSAMSensorNorm, //!< Normalized SAM channel derived through data analysis
		eAngleRef, //!< Orientation of head localization field
		eExtractionRef, //!< Extracted signal from each sensor of field generated by each localization coil
		eFitErr, //!< Fit error from each head localization head coil
		eOtherRef, //!< Any other type of sensor not mentioned, but is still valid
		eInvalidType //!< An invalid sensor
	} SensorType;
	typedef enum {
		MEGRef, //!< All MEG sensors located above the helmet
		MEGSensor, //!< All MEG sensors located in the helmet
		EEGRef, //!< All EEG sensors that are not on the scalp
		EEGSensor, //!< All EEG sensors that are on the scalp
		ADCRef, //!< All ADC channels measured in amps
		StimRef, //!< All stim channels
		TimeRef, //!< All time channels
		PositionRef, //!< Unused
		DACRef, //!< All DAC channels
		SAMSensor, //!< All derived SAM channels
		VirtualSensor, //!< All derived virtual channels
		badMEGSensor,
		badEEGSensor,
		ADCVoltRef, //!< All ADC channels measured in volts
		SuppRef, //!< Supplementary channels, MEGReset and EEG_AFLG
		DipoleSource, //!< All dipole source channels
		AngleRef, //!< Orientation vector of a head localization coil
		ExtractionRef, //!< Measured data at a sensor of the head localization coils
		FitErr, //!< Fit error from head localization coils
		OtherRef,
		InvalidClass
	} eChType;
	typedef eChType SensorClass;
	typedef enum {
		CIRCULAR,
		SQUARE,
		VOLTMETER = CIRCULAR,
		AMMETER = SQUARE
	} coiltype;
	typedef coiltype CoilType;
	typedef union d3_point
	{
		struct { double x, y, z, junk; } c;
		struct { double r, theta, phi, junk; } s;
		double point[4];
	} d3_point;
	typedef union d2_point
	{
		struct { double x, y; } c;
		struct { double r, theta; } p;
		double point[2];
	} d2_point;
	typedef union d3_point_ext /* Externally store points as float */
	{
		struct { float x, y, z, junk; } c;
		struct { float r, theta, phi, junk; } s;
		float point[4];
	} d3_point_ext;
	typedef struct CoilRec_ext
	{
		d3_point_ext position; /* position of coil */
		d3_point_ext orient; /* orientation of coil */
		qint16 numturns; /* number of turns making up the coil */
		short reserved1; /* pad out to the next 8 byte boundary */
		short reserved2;
		short reserved3;
		float area; /* area of coil */
	} CoilRec_ext __PACKED__;
	typedef struct CoilRec
	{
		d3_point position; /* position of coil */
		d3_point orient; /* orientation of coil */
		qint16 numturns; /* number of turns making up the coil */
		double area; /* area of coil */
	} CoilRec __PACKED__;
	typedef struct coef_List
	{
		qint16 index;
		char name[SENSOR_LABEL];
	} Coef_List __PACKED__;
	typedef struct
	{
		qint16 sensorTypeIndex;
		qint16 originalRunNum;
		CoilType coilShape;
		float properGain; /* may be corrected */
		float qGain;
		float ioGain;
		float ioOffset;
		qint16 numCoils;
		qint16 grad_order_no;
		long stimPolarity;
		CoilRec_ext coilTbl[MAX_COILS];
		CoilRec_ext HdcoilTbl[MAX_COILS];
	} __PACKED__ NewSensorResRec;

	typedef struct CoefResRec /* Making generic resource for coefficients. */
	{
		qint16 num_of_coefs;
		char sensor_list[MAX_BALANCING][SENSOR_LABEL];
		float coefs_list[MAX_BALANCING];
	} __PACKED__ CoefResRec, *CoefResRecP, **CoefResRecH;
	typedef struct
	{
		char nf_run_name[32],
			nf_run_title[256],
			nf_instruments[32],
			nf_collect_descriptor[32],
			nf_subject_id[32],
			nf_operator[32],
			nf_sensorFileName[56];
		qint32 size; /* length of following array */
		long reserved1; /* pad out to the next 8 byte boundary */
		CStrPtr nf_run_descriptor;
	} __PACKED__ meg4FileSetup;
	typedef enum { CLASSERROR, BUTTERWORTH } classType;
	typedef enum { TYPERROR, LOWPASS, HIGHPASS, NOTCH } filtType;
	typedef struct
	{
		float freq;
		classType fClass;
		filtType fType;
		qint16 numParam;
		SDoubleArr params;
	}__PACKED__ filter;
	/*
	* This enum is used by GeneralRsrc to keep track of which
	* part of the trigger format union it will be reading
	*/
	enum TriggerStructFormat { MEG40_TRIG_FMT, MEG41_TRIG_FMT, MEG42_TRIG_FMT };
	/*
	* Trigger structure for the meg4 dataset
	*/
	typedef struct
	{
		UCChar primaryTrigger;
		UCChar secondaryTrigger[MAX_AVERAGE_BINS];
		UCChar triggerPolarityMask;
	}__PACKED__ meg40TriggerData;
	/*
	* Trigger structure for the meg5 dataset
	*/
	typedef struct
	{
		Bit32 primaryTrigger;
		Bit32 triggerPolarityMask;
	}__PACKED__ meg41TriggerData;
	typedef struct
	{
		qint32 no_samples;
		qint16 no_channels;
		short reserved1; /* pad out to the next 8 byte boundary */
		float sample_rate;
		float epoch_time;
		qint16 no_trials;
		short reserved2; /* pad out to the next 8 byte boundary */
		qint32 preTrigPts;
		qint16 no_trials_done;
		qint16 no_trials_display;
		CTFBoolean save_trials;
		union
		{
			meg40TriggerData meg40trig;
			meg41TriggerData meg41trig;
		};
		short reserved3; /* pad out to the next 8 byte boundary */
		qint16 trigger_mode;
		short reserved4; /* pad out to the next 8 byte boundary */
		CTFBoolean accept_reject_Flag;
		qint16 run_time_display;
		short reserved5; /* pad out to the next 8 byte boundary */
		CTFBoolean zero_Head_Flag;
		CTFBoolean artifact_mode;
	}__PACKED__ new_general_setup_rec_ext;
	struct meg41GeneralResRec
	{
		CStr256 appName;
		CStr256 dataOrigin;
		CStr256 dataDescription;
		qint16 no_trials_avgd;
		char data_time[255];
		char data_date[255];
		new_general_setup_rec_ext gSetUp;
		meg4FileSetup nfSetUp;
	} __PACKED__; // so we don’t have alignment problems
				  // padding is by explicit declarations
	typedef struct meg41GeneralResRec meg41GeneralResRec;
	typedef struct
	{
		CStr32 sensorName;
		Bit32 coefType;
		long reserved1; /* pad out to the next 8 byte boundary */
		CoefResRec coefRec;
	} SensorCoefResRec;
	/// fiducials struct
	struct FidPoints_t
	{
		Point_3D nasion;
		Point_3D leftEar;
		Point_3D rightEar;
	};
	/// List of MEG system types
	static const string CTFMEGSystemType[] = { "cmeg",
		"fmeg",
		"Untitled" };
	/**
	Enumerator for MEG system type
	This values can not be change as they are stored in the dataset info file. enum can be only extended.
	*/
	enum CTFMEGSystemType_t
	{
		CTFMEGSystemType_CMEG = 0,
		CTFMEGSystemType_FMEG,
		CTFMEGSystemType_UNKNOWN
	};
#ifdef __cplusplus
}
#endif